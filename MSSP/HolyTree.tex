\documentclass{article}

\usepackage{amsmath, ../packages/enumitem, listings, graphicx, ../packages/jeffe}
\oddsidemargin 0in
\evensidemargin 0in
\textwidth 6.5in
\topmargin -0.5in
\textheight 9.0in

\begin{document}

\title{Multiple Source Shortest Path with unit weights}

% Title
\begin{center}
\textbf{\large Multiple-source shortest paths with unit weights in embedded
graphs}
\end{center}

\DRAFT

\begin{bigabstract}
We describe a new algorithm that computes multiple-source shortest paths from
vertices in a given boundary face to all other vertices in an embedded graph
with unit weight edges.
\end{bigabstract}

\section{Introduction}

Recently, Eisanstat and Klein $[?]$ introduced a new algorithm for computing
multiple source shortest path problem for a planar graphs in linear time. Our 
paper attempts to generalize this idea to embedded graphs. In their paper,
they maintain so-called leafmost shortest tree to get around an issue of 
ambiguous shortest paths between a pair of vertices. There is no direct way 
to generalize leafmost tree computing process to an embedded graphs, largely
because there is no way to define leafmost tree of a data structure in an
embedded graphs. In the following section we introduce terms that alleviate
the process of ambiguous pivoting.\\

We can formally define multiple-source shortest paths problem as follows: \\

\begin{center}
{\color{red}Introduce notations, homology, and dual graphs.}
\end{center}

\begin{oneshot}{Given}
Let $G$ be a directed graph $(V, \vec{E})$, embedded on a surface with genus $g$.
All edge weights are unit and $|V| = n$. Using Euler's theorem, we can derive 
$|E| = n + 2g - 1$.
\end{oneshot}

\begin{oneshot}{Find}
Consider boundary face $f$ of $G$. $\forall v \in f$, find a shortest path to
$\forall u \in V$.
\end{oneshot}

Let $T$ be a breadth first search(BFS) tree of $G$, and $C^{*}$ be a BFS 
co-tree in $G$. Then there is exactly $2g$ leftover edges 
$L = \{e_1, e_2, \ldots, e_{2g}\}$. \\

There exists a unique cycle $\lambda_i$ in $C^{*} \cup {e_i}$, and $(\lambda_1, 
\lambda_2, \ldots, \lambda_{2g}) = \Lambda$ defining homology basis. \\
We define homological signature of an edge as follows:
\[ [e]_{i} = \begin{cases} 1 & ,\mbox{if } e \in \lambda_i \\
                          -1 & ,\mbox{if } rev(e) \in \lambda_i \\
                           0 & ,\mbox{o/w} \end{cases}\]

Furthermore, we define leafmost term $\alpha$ recursively as follows: \\
\[ \alpha(e^*) = 
  \begin{cases} 1 & ,\mbox{if } rev(e^*) \mbox{ is a leaf dart in } C^{*} \\
                           \sum \limits_{ \text{tail}(e^{'*})
                           = \text{head}(e^*) } \alpha(e^{'}) & ,
                           \mbox{o/w} \end{cases}\]
We can extend above definition with $\alpha(e) = \alpha(e^*)$ and 
  $\alpha(e)^* = - \alpha(\text{rev}(e^*))$. \\

Let $\tilde w(e) = ( 1, \vec{[e]}, \alpha(e) )$ be new
weight vector for each edge in $G$. We refer to each component this weight vector
as length, homology, and leafmost terms respectively.

\begin{center}
\includegraphics[scale = 0.5]{g1.jpg}
\end{center}
\vspace{-4.0cm} % Remove the space after the picture.

\begin{oneshot}{Definition}
An edge $e_1$ is holier than $e_2$, 
if $\tilde w(e_1) < \tilde w(e_2)$ in lexicographic comparison. 
Therefore, we can define holiness of any $S \subset G $ as follows:
\[\text{H}(S) = \sum \limits_{e \in S} \tilde w(e)\]
\end{oneshot}

\section{Need of holiness}
We provide a simple explanation on why it is necessary to introduce holiness
to cope with ambiguity. \\

\begin{center}
{\color{red}
1. Describe why homology and leafmost term resolves the issue in higher
genus graphs.}
\end{center}

\section{Initial holy tree}

Holiest tree is a spanning tree with minimal holiness. We build holiest tree 
rooted at $r$, using slight tweak in the Bellman-Ford algorithm for finding 
shortest path tree rooted at r. \\

\begin{minipage}[t]{0.48\linewidth}
\begin{algorithm}
\textbf{\underline{BuildHoliestTree}}($G, \tilde w , r$): \\ \quad
Set $dist[r] \leftarrow ( 0, \vec{[0]}, 0 )$ \\ \quad \quad
    pred($r$) $\leftarrow$ NULL \\ \quad
for all $v : v \neq r$ \\ \quad \quad
    $dist[r] \leftarrow ( \infty, \vec{[\infty]}, \infty )$ \\ \quad \quad
    pred($r$) $\leftarrow$ NULL \\ \quad
put $r$ into queue \\ \quad
while queue is not empty: \\ \quad \quad
    Let $u \leftarrow$ dequeue item \\ \quad \quad
    for all $u \rightarrow v$ \\ \qquad \quad
        if $v$ is not marked \\ \quad \qquad \quad
           mark $v$ and put in the queue \\ \qquad \quad
        if isTense($u \rightarrow v$) \\ \quad \qquad \quad
           relax($u \rightarrow v$)
\end{algorithm}
\end{minipage}
\hfill%
\hspace{-4cm}
\begin{minipage}[t]{0.48\linewidth}
\begin{algorithm}
\textbf{\underline{isTense}}($u \rightarrow v$): \\ \quad
return $dist[u] + \tilde w(u \rightarrow v) < dist[v]$ \\

\end{algorithm}

\vspace{0.5cm}

\begin{algorithm}
\textbf{\underline{relax}}($u \rightarrow v$): \\ \quad
$dist[v] \leftarrow dist[u] + \tilde w(u \rightarrow v)$ \\ \quad
pred[v] $\leftarrow u$ \\
\end{algorithm}
\end{minipage}

\vspace{0.5cm}

\begin{oneshot}{Observation}
Each vertex will be added once to the queue.
\end{oneshot}

\begin{oneshot}{Corollary}
Each edge will be relaxed at most once.
\end{oneshot}

\begin{oneshot}{Lemma 2.1}
If there is no tense edge in $G$, then for each 
$v: r \rightarrow \ldots \rightarrow \text{pred}(\text{pred}(v)) \rightarrow 
\text{pred}(v) \rightarrow v$ is the holiest path from $r$ to $v$.
\end{oneshot}
\begin{proof}
Let's prove it by induction on $dist[v].length$ distance from the root
$r$.
\begin{oneshot}{Base}
$dist[v].length = 0$, then v = r, so the claim holds trivially.
\end{oneshot}

\begin{oneshot}{Induction Step}
Suppose the claim is true for all vertex $v \in V$ 
such that $dist[v].length < d$ for some d. Consider vertex v such that 
$dist[v].length=d$. By induction hypothesis, all vertices with 
$dist[u].length = d-1$ have holiest path 
correctly updated. By definition, $dist[v] = \min\limits_{u \rightarrow v}\{
dist[u] + \tilde w(u \rightarrow v)\}$, here $dist[u].length = d-1$. 
By Induction hypothesis, $dist[u]$ is not tense and can construct holiest 
path to $u$, so if there is no tense edge in G then 
$dist[v] = \text{min}\{dist[u] + \tilde w(u \rightarrow v)\}$ 
holds.
\end{oneshot}
\end{proof}

\begin{oneshot}{Corollary}
The algorithm will produce holiest tree rooted at r in $O(n + g)$ time.
\end{oneshot}

\section{Moving Along an Edge}

Let $T_u$ be a current holiest tree, $u \rightarrow v$ be an edge that we are
trying to move along. So at the end of the process we would like to obtain
$T_v$, the holiest tree rooted at v. \\

We follow Caballo, Chambers, and Erickson's $[?]$ method to move across the edge,
by bisecting the given edge and inserting new source s which is connected to
both $u$ and $v$. At the start of the process, $s == u$ and continuously move to
v, and when $s == v$, we would have our $T_s = T_v$. \\

\textbf{Initial attempt:}

Let $(1, \vec{h}, \alpha) = w(u \rightarrow v)$. We treat $\lambda$ as a
parameter with satisfying following equations:

\begin{align}
&w_{u}(s \rightarrow u) = (0, \vec{[0]}, 0), \quad
  w_{u}(s \rightarrow v) = (1, \vec{h}, \alpha) \\
&w_{v}(s \rightarrow u) = (1, -\vec{[h]}, -\alpha), \quad
  w_{v}(s \rightarrow v) = (0, \vec{0}, 0)
\end{align}

The natural definition would be as follows, but it does not satisfy our
constraints $(1)-(2)$.
\begin{align}
&w_{\lambda}(s \rightarrow u) = (\lambda, \vec{[0]}, 0)  \\
&w_{\lambda}(s \rightarrow v) = (1 - \lambda, \vec{h}, \alpha)
\end{align}

Therefore, we modify our parametric definition by decreasing distance to u by
$w(u \rightarrow v) = (0, -\vec{[h]}, -\alpha)$. This change allows us to define

\begin{align}
&w_{\lambda}(s \rightarrow u) = (0, -\vec{[h]}, -\alpha) + 
\lambda * (1, \vec{[h]}, \alpha)  \\
&w_{\lambda}(s \rightarrow v) = (1, \vec{[h]}, \alpha) + 
\lambda * (1, \vec{[h]}, \alpha)
\end{align}

Since we decrease distance to $u$ at the start, this could potentially introduce
pivots. Suppose, for instance, $x$ be descendant of $u$ and $y$ be of $v$ in $T_s$,
then:
\begin{align}
& slack(x \rightarrow y) = dist(x) + w(x \rightarrow y) - dist(y) = \\
& = dist_0(x) + (0, -\vec{[h]}, -\alpha) + w(x \rightarrow y) - dist_0(y) = \\
& = slack_0(x \rightarrow y) + (0, -\vec{[h]}, -\alpha) \Rightarrow \\
& slack(x \rightarrow y) < 0, \text{ if } slack_0(x \rightarrow y) < 
(0,\vec{[h]},\alpha)
\end{align}

Therefore, this could be potentially problamatic. Furthermore, \textbf{What if 
$u \rightarrow v$ has non-trivial homology or leafmost term?}

We need to take into account that $u \rightarrow v$ has non-trivial homology and
leafmost terms. 
\begin{center}
{\color{red}
1. First attempt of not maintain holy tree at all times.
\\
2. Second attempt of continuously moving by changing homology and 
leafmost terms, also reducing destination distance initially.
\\ 
3. Necessity of resolving homology and leafmost values for an edge 
that source is moving.}
\end{center}

\begin{align}
& w_{0}(s \rightarrow u) = ( 0, \vec{[0]}, 0 ) \\
& w_{0}(s \rightarrow v) = ( 1, \vec{[h]}, \alpha ) = w(u \rightarrow v)
\end{align}

Observe that this condition implies $s = u$, therefore $T_s = T_u$. We reduce 
distances to u and v as follows:

\begin{align}
& w_{\epsilon}(s \rightarrow u) = ( 0, -\vec{[h]}, -\alpha ) \\ 
& w_{\epsilon}(s \rightarrow v) = ( 1, \vec{[0]}, 0 )
\end{align}

Since we reduced distance to all vertices in the graph equally, the process does
not introduce any pivots. Then we define a parametric weights as follows:

\begin{align}
& w_{\lambda}(s \rightarrow u) = ( 0, -\vec{[h]}, -\alpha ) - \lambda \\
& w_{\lambda}(s \rightarrow v) = ( 1, \vec{[0]}, 0 )  + \lambda 
\end{align}

Every other dart $x \rightarrow y$ has constant parametric weight 
$w_{\lambda}(x \rightarrow y) = w(x \rightarrow y)$.
We then maintain the holy tree $T_{\lambda}$ rooted at s, with respect
to the weight function $w_{\lambda}$, as $\lambda$ increases continuously from
0 to $( 1, \vec{[0]}, 0 )$. When $\lambda = w(u \rightarrow v)$, 
$T_{\lambda} = T_v$.

In the following algorithm, \textbf{pred} defines holy tree rooted at $u$, and 
\textbf{dist} is corresponding distance to each vertex in the graph. \\

% To ensure that introducing $dist_0[s \rightarrow u] = ( 0, -2 * [
% w(u \rightarrow v)], -2 * \alpha(w(u \rightarrow v)) )$ does 
% not introduce any dart with negative slack, we carefully choose fundamental 
% homology cycles to not cross any of the darts of boundary face f. If we assume
% that moving around the face process is counter-clockwise as shown below,
% $\forall u_i -> u_{i + 1} \in f, \alpha(w(u_i \rightarrow u_{i + 1})) <= 0$.
% Therefore, $dist[s \rightarrow u] = ( 0, -2 * [
% w(u \rightarrow v)], -2 * \alpha(w(u \rightarrow v)) )  + \lambda
% = ( 0, [0], -2 * \alpha(w(u \rightarrow v)) )  + \lambda$. Since we
% are adding non-negative distance to u, no slack will be nonnegative by
% construction. 

\begin{center}
\begin{algorithm}
\textbf{\underline{MoveAlongEdge}}($G, u \rightarrow v, dist, pred$): \\ \quad
Add new vertex s \\ \quad
$pred[u], pred[v] \leftarrow s$ \\ \quad
$\lambda \leftarrow 0$ \\ \\ \quad

$w(s \rightarrow u) \leftarrow ( 0, -[w(s \rightarrow u)], 
-\alpha(w(s \rightarrow u)) )$ \\ \quad
AddSubtree$(( 0, -[w(s \rightarrow u)], 
-\alpha(w(s \rightarrow u)) ), u)$ \\ \\ \quad

$w(s \rightarrow v) \leftarrow ( 1, \vec{[0]}, 0 )$ \\ \quad
AddSubtree$(( 0, -[w(s \rightarrow u)], 
-\alpha(w(s \rightarrow u)) ), v)$ \\ \\ \quad

while $\lambda < ( 1, \vec{[0]}, 0 )$: \\ \quad \quad
    \textbf{pivot} $\leftarrow $ FindNextPivot \\ \quad \quad
    If \textbf{pivot} is non NULL \textbf{AND} 
    $(\lambda + slack(\textbf{pivot}) / 2) < ( 1, \vec{[0]}, 0 )$ \\ \qquad \quad
        Pivot(\textbf{pivot}) \\ \qquad \quad
        $\lambda \leftarrow \lambda + slack(\textbf{pivot}) / 2$ \\ \quad \quad
    else \\ \qquad \quad
        $\delta = ( 1, \vec{[0]}, 0 ) - \lambda$ \\ \qquad \quad
        AddSubtree$(\delta, u)$ \\ \qquad \quad
        AddSubtree$(-\delta, v)$ \\ \qquad \quad
        $\lambda \leftarrow \lambda + \delta$ \\
\end{algorithm}
\end{center}

\section{Bounding number of pivots}

\begin{center}
{\color{red}
1. Describe how Eisenstat Klein clock lemma works and why it is not easily
generalizable in higher genus graphs. 
\\
2. Describe $P_i^{v}, P_j^{v}$ non-crossing.}
\end{center}

We introce a clocking lemma to prove that each edge is involved in pivoting 
process at most $O(g)$ times.

\begin{oneshot}{Lemma 4.1}
Let $v_0$ be a first vertex in our given face $f$, and $v_i$ be the source right
after $i^{th}$ pivot. Consider a vertex $y$. We denote holiest path from 
$v_i$ to $y$ as $P_i^{y}$. Then $P_i^{y}$ and $P_j^{y}$ are non-crossing for 
all $i, j$.
\end{oneshot}
\begin{proof}
This is immediate from our definition of holiest path, as no two paths can have
same value. {\color{red} [???]}
\end{proof}

\begin{oneshot}{Lemma 4.2}
As source vertex $s$ moves around the given face f, any dart $d$ has exactly
$2g$ continuous clock state: 
\begin{align}
& d \in T \\
& d^{*} \in (G/T)^{*} \\
& rev(d) \in T \\
& rev(d^{*}) \in (G/T)^{*}
\end{align}
\end{oneshot}
\begin{proof}
Here is the proof.
\end{proof}


\begin{oneshot}{Theorem 4.1}
Total running time of MSSP is $O(gn)$.
\end{oneshot}
\begin{proof}
Building initial holy tree takes $O(n + g)$ time. The process of moving arond the
face and pivoting takes $O(gn)$ as each dart enters and replaces $O(g)$ times.
\end{proof}

\section{Finding pivot quickly}
\begin{itemize}
\item What data structure do we maintain in the G*?
Finding shortest path in network can also be understood as a Linear Programming 
problem as follows:
\item How do we find next pivot quickly using above structure?
\end{itemize}

\section{Analysis}
\begin{itemize}
\item Building initial tree
\item Pivoting
\item Number of times each edge is pivoted
\item Overall running time
\end{itemize}

Couple questions regarding the slack and flow:
\begin{itemize}
\item If the fixed tree T is arbitrary tree (not necessarily the holiest Tree, 
then the flow in the answer does not have to be optimal) but solution to the 
linear program $min <f, \text{slack}_T>$ is equal to the answer from fixed tree T, 
not necessarily the optimal solution. That is because for each vertex, the 
demand satisfies the constraint and if we consider the tree T, then the value of 
$min <f, \text{slack}_T>$ would be 0, implying it is the optimal solution. 
(Sum cannot be negative since otherwise there is no optimal solution)
\item The reason we picked the slack as the way we defined is due to the fact 
that slack is not negative, ensuring that the nothing bad happens.
\item What makes the non-planar case special with 2g extra constraints?
\item How does the slack in dual representation help us to find the pivots quickly?
\end{itemize}

\section{Additional}
\textbf{NOTE: } Necessity of the $\alpha$ definition on the edges for holiness.  
\\
Consider the following picture:
\begin{center}
\includegraphics[angle = 90, scale = 0.3]{alphaNec.jpg}
\end{center}
By the definition of $alpha$:
\[\alpha(p_1) - \alpha(p_2) = \sum_f \alpha(\partial f) > 0\]
This will ensure that any two paths $p_1, p_2$, whose $w(p_1) = w(p_2)$ and 
  $[p_1]_{\Lambda} = [p_2]_{\Lambda}$, has $\alpha(p_1) \neq \alpha(p_2)$

\begin{center}
\includegraphics{torus.jpg}
\end{center}
$\href{http://en.wikipedia.org/wiki/Homology_(mathematics)}{http://en.wikipedia.org/wiki/Homology_(mathematics)}$

\newpage
\section{Working on examples:}
\textbf{Difference of holiest Tree and leftmost tree:} \\
On genus $g = 1$ surface:
\begin{center}
\includegraphics[scale = 0.6]{genus1.jpg}
\end{center}




\newpage
On genus $g = 2$ surface:
\begin{center}
\includegraphics[angle = -90, scale = 0.7]{genus2.jpg}
\end{center}



\newpage
On genus $g = 3$ surface:
\begin{center}
\includegraphics[angle = -90, scale = 0.7]{genus3.jpg}
\end{center}



\newpage
On genus $g = 4$ surface with initial Holy Tree build:
\begin{center}
\includegraphics[angle = -90, scale = 0.7]{Genus4_InitialHolyTree.jpg}
\end{center}



\newpage
On genus $g = 4$ surface with initial pivot:
\begin{center}
\includegraphics[angle = -90, scale = 0.7]{genus4_initialPivot.jpg}
\end{center}



\newpage
On genus $g = 4$ surface with initial pivot:
\begin{center}
\includegraphics[angle = -90, scale = 0.7]{genus4_after4Pivots.jpg}
\end{center}




\newpage
On genus $g = 5$ surface with initial pivot:
\begin{center}
\includegraphics[angle = -90, scale = 0.7]{genus4_after5Pivots.jpg}
\end{center}




\newpage
\section{References:}
\begin{itemize}
\item Cabello, Sergio, Erin W. Chambers, and Jeff Erickson. "Multiple-source 
  shortest paths in embedded graphs." SIAM Journal on Computing 42.4 (2013): 1542-1571.
\item Eisenstat, David, and Philip N. Klein. "Linear-time algorithms for max 
  flow and multiple-source shortest paths in unit-weight planar graphs." 
  Proceedings of the forty-fifth annual ACM symposium on Theory of computing. ACM, 2013.
\item Erickson, Jeff. Maximum flows and parametric shortest paths in planar graphs.
  Proceedings of the twenty-first annual ACM-SIAM symposium on Discrete Algorithms. 
  Society for Industrial and Applied Mathematics, 2010.
\end{itemize}
\end{document}
